<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: radial-gradient(circle at center, #1a0033 0%, #000 100%);
    font-family: 'Inter', sans-serif;
  }
  canvas {
    position: fixed;
    top: 50%; left: 50%;
    width: 100%; height: 100vh;
    transform: translate(-50%, -50%);
    z-index: 1;
  }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 12);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.rotateSpeed = 0.5;
controls.minDistance = 3;
controls.maxDistance = 25;
controls.target.set(0, 0, 0);
controls.update();

scene.add(new THREE.AmbientLight(0x1a0033, 0.8));
const dirLight = new THREE.DirectionalLight(0xff66cc, 0.4);
dirLight.position.set(5, 10, 7.5);
scene.add(dirLight);
const dirLight2 = new THREE.DirectionalLight(0x00ffff, 0.3);
dirLight2.position.set(-5, -10, -7.5);
scene.add(dirLight2);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.2, 0.6, 0.9
);
bloom.threshold = 0.1;
bloom.strength = 1.4;
bloom.radius = 0.8;
composer.addPass(bloom);
composer.addPass(new FilmPass(0.5, 0.4, 1024, false));
const rgbShift = new ShaderPass(RGBShiftShader);
rgbShift.uniforms['amount'].value = 0.003;
composer.addPass(rgbShift);

const geoTeapot = new TeapotGeometry(5, 15, true, true, true, true, true);
geoTeapot.computeBoundingBox();
const center = new THREE.Vector3();
geoTeapot.boundingBox.getCenter(center);
geoTeapot.translate(-center.x, -center.y, -center.z);

const positions = geoTeapot.attributes.position.array;
const count = positions.length / 3;
console.log(`Created teapot with ${count} particles.`);

const geom = new THREE.BufferGeometry();
geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

const colArr = new Float32Array(count * 3);
const origCols = [];
const twinkle = [];
const sizes = new Float32Array(count);

const palette = [
  new THREE.Color(0x00ffff),
  new THREE.Color(0xff0080),
  new THREE.Color(0x8000ff),
  new THREE.Color(0x00ff40),
  new THREE.Color(0xff4000),
  new THREE.Color(0x4080ff)
];

for (let i = 0; i < count; i++) {
  const t = i / (count - 1);
  const colorIndex = t * (palette.length - 1);
  const c1 = palette[Math.floor(colorIndex)];
  const c2 = palette[Math.min(Math.ceil(colorIndex), palette.length - 1)];
  const mix = colorIndex % 1;
  const col = new THREE.Color().lerpColors(c1, c2, mix);
  col.multiplyScalar(1.3);
  colArr.set([col.r, col.g, col.b], i * 3);
  origCols.push(col.clone());
  twinkle.push(Math.random() < 0.5 ? Math.random() * 6 + 3 : 0);
  sizes[i] = 0.02 + Math.random() * 0.04;
}

geom.setAttribute('color', new THREE.Float32BufferAttribute(colArr, 3));
geom.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

const mat = new THREE.PointsMaterial({
  size: 0.03,
  vertexColors: true,
  sizeAttenuation: true,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const particles = new THREE.Points(geom, mat);
particles.userData = { origCols, twinkle };
scene.add(particles);

const clock = new THREE.Clock();
let time = 0;

function applySparkle(sys, t) {
  const colors = sys.geometry.attributes.color;
  const { origCols, twinkle } = sys.userData;
  for (let i = 0; i < colors.count; i++) {
    if (twinkle[i] > 0) {
      const p = Math.pow(Math.abs(Math.sin(twinkle[i] * t + i * 0.1)), 10);
      const b = 1 + 4 * p;
      const oc = origCols[i];
      colors.setXYZ(i, oc.r * b, oc.g * b, oc.b * b);
    }
  }
  colors.needsUpdate = true;
}

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  time += dt;
  particles.rotation.y += 0.005;
  applySparkle(particles, time);
  controls.update();
  composer.render();
}

window.addEventListener('resize', () => {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  composer.setSize(w, h);
});

animate();
</script>
